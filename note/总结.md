1. 数据库两次入库改为先记入缓存，再一次入库，入库改为放到队列中
2. 所有同步代码改为异步调用，增加并发能力
3. Domain模块，new初始化改为依赖注入为单例
4. Nginx配置Http转发为长连接
5. 优化反射性能：拦截规则反射改为表达式树方式
6. 图片功能：对图片进行压缩、配置nginx静态缓存、增加图片服务器



### 秒杀系统设计

前端：

- 增加CDN服务器，减轻秒杀服务器压力
- URL动态化，需要前端获取请求真实地址
- 前端限流，秒杀前按钮不可点击，秒杀中点击后需过几秒才可继续点击

后端：

- 增加服务节点，通过nginx负载均衡
- 恶意请求拦截
- 风控，分析用户是机器还是人操作
- 微服务架构，秒杀系统崩溃不会影响其他业务
- Redis集群、Redis事务、锁
- MQ，削峰填谷
- 分布式事务，两段提交、三段提交

https://zhuanlan.zhihu.com/p/169464555

### Token 认证

认证的前提是？

### 线程交替打印

#### 1. volatile

```java
public static volatile int i = 0;
public static void main(String[] args) {
    new Thread(() -> {
        while (i < 100) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
            }
        }
    }).start();
    new Thread(() -> {
        while (i < 100) {
            if (i % 2 == 1) {
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
            }
        }
    }).start();
}
```

#### 2. synchronized

```java
public static Object lock = new Object();
static int i = 0;
public static void main(String[] args) {
    new Thread(() -> {
        synchronized (lock) {
            while (i < 100) {
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
                lock.notify();
                try {
                    lock.wait();
                } catch (InterruptedException ex) {
                }
            }
            lock.notifyAll();
        }
    }).start();
    new Thread(() -> {
        synchronized (lock) {
            while (i < 100) {
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
                lock.notify();
                try {
                    lock.wait();
                } catch (InterruptedException ex) {
                }
            }
            lock.notifyAll();
        }
    }).start();
}
```

#### 3. lock

```java
static int i = 0;
public static void main(String[] args) {
    Lock lock = new ReentrantLock();//锁
    Condition t1 = lock.newCondition();//t1队列
    Condition t2 = lock.newCondition();//t2队列
    new Thread(() -> {
        try {
            lock.lock();
            while (i < 100) {
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
                t2.signal();//唤醒t2队列中等待的线程
                t1.await();//进入t1队列自旋等待
            }
            t1.signal();//避免有线程未被唤醒
            t2.signal();//避免有线程未被唤醒
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }).start();
    new Thread(() -> {
        try {
            lock.lock();
            while (i < 100) {
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
                t1.signal();//唤醒t1队列中等待的线程
                t2.await();//进入t2队列自旋等待
            }
            t1.signal();//避免有线程未被唤醒
            t2.signal();//避免有线程未被唤醒
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }).start();
}
```

#### 4. Semaphore

```java
static int i = 0;
public static void main(String[] args) {
    Semaphore A = new Semaphore(1);
    Semaphore B = new Semaphore(0);
    new Thread(() -> {
        while (i < 100) {
            try {
                A.acquire();
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
            } catch (Exception e) {
                e.printStackTrace();
            }
            B.release();
        }
    }).start();
    new Thread(() -> {
        while (i < 100) {
            try {
                B.acquire();
                System.out.println(Thread.currentThread().getId() + "：" + i);
                i++;
            } catch (Exception e) {
                e.printStackTrace();
            }
            A.release();
        }
    }).start();
}
```

