## ZooKeeper

### 基本概念

#### ① 集群角色

没有沿用传统的 Master/Slave 概念，而是引入了 **Leader、Follower、Observer** 三种角色。

zookeeper 集群中的所有机器通过 Leader 选举来选定一台被称为 Leader 的机器，Leader 服务器为客户端提供读和写服务。除Leader 外，其他机器包括 Follower 和 Observer也能供读服务，Follower 和 Observer 唯一的区别是 Observer 不参与 Leader 选举过程，不参与写操作的过半写成功策略，因此 Observer 可以在不影响写性能的情况下提升集群的性能

#### ② 会话（Session）

Session 指客户端会话，通过这个连接，客户端能够心跳检查与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能通过该连接接受来自服务器的 Watch 时间通知。

#### ③ 数据节点（Znode）

- znode是zookeeper树形结构中的数据节点，用于存储数据；
- zookeeper中有两种类型的节点：
  - 持久节点：一旦创建，除非主动调用删除操作，否则一直存储在zk上；
  - 临时节点：与客户端会话绑定，一旦会话失效，这个客户端所创建的所有临时节点都会被移除；

- 节点的顺序(SEQUENTIAL)属性：创建子节点时，如果设置SEQUENTIAL属性，则会自动在节点名后追加一个整形数字，上限是整形的最大值；

#### ④ 版本

zookeeper 的每个ZNode 上都会存储数据，对于每个ZNode，zookeeper都会为其维护一个叫做 stat 的数据结构，Stat 记录了这个ZNode的三个数据版本，分别是 version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）、aversion（当前ZNode的ACL版本）

#### ⑤ Watcher（事件监听器）

zookeeper 提供了分布式数据的发布/订阅功能，zookeeper允许客户端向服务端注册一个 watcher 监听，Watcher 通知是一次性的，即一旦触发一次通知后，该 Watcher 就失效了，因此客户端需要反复注册Watcher

#### ⑥ ACL

zookeeper 采用ACL（Access Control Lists）策略来进行权限控制

### 应用1-注册中心

ZooKeeper是一个树形结构的目录服务，支持变更推送，因此可以作为服务的注册中心。

注册中心工作流程

#### 1. 服务提供方启动

服务提供者在启动的时候，会在ZooKeeper上注册服务。所谓注册服务，其实就是在ZooKeeper的/dubbo/com.foo.BarService/providers节点下创建一个子节点，并写入自己的URL地址，这就代表了com.foo.BarService这个服务的一个提供者。

#### 2. 服务消费者启动

服务消费者在启动的时候，会向ZooKeeper注册中心订阅自己的服务。其实，就是读取并订阅ZooKeeper上/dubbo/com.foo.BarService/providers节点下的所有子节点，并解析出所有提供者的URL地址来作为该服务地址列表。

同时，服务消费者还会在ZooKeeper的/dubbo/com.foo.BarService/consumers节点下创建一个临时节点，并写入自己的URL地址，这就代表了com.foo.BarService这个服务的一个消费者。

#### 3. 消费者远程调用提供者

服务消费者，从提供者地址列表中，基于软负载均衡算法，选一个提供者进行调用，如果调用失败，再选另一个提供者调用。

#### 4. 增加服务提供者

增加提供者，也就是在providers下面新建子节点。服务消费方监听provider节点，一旦该节点的内容有变动，provider就会将一个变更通知推送给所有客户端，客户端收到通知后就会主动去provider那拉取最新的服务地址列表。

#### 5. 减少服务提供者

所有提供者在ZooKeeper上创建的节点都是临时节点，利用的是临时节点的生命周期和客户端会话相关的特性，因此一旦提供者所在的机器出现故障导致该提供者无法对外提供服务时，该临时节点就会自动从ZooKeeper上删除，同样，zookeeper会把provider节点数据变更通知推送给consumer

### 应用2-分布式锁

#### 分布式排它锁

利用 zookeeper 的同级节点的唯一性特性，在需要获取排他锁时，所有的客户端试图通过调用 create() 接口，在 **/exclusive_lock** 节点下创建临时子节点 **/exclusive_lock/lock**，最终只有一个客户端能创建成功，那么此客户端就获得了分布式锁。同时，所有没有获取到锁的客户端可以在 **/exclusive_lock** 节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。

#### 分布式共享锁

共享锁的特点：不同事务都可以同时对同一个对象进行读取，而更新操作必须在没有任何事务的情况下进行。

1. 使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点。

2. 创建节点成功后，获取目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点

3. 如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。

4. 如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。

   比如当前线程获取到的节点序号为`/lock/003`,然后所有的节点列表为`[/lock/001,/lock/002,/lock/003]`,则对`/lock/002`这个节点添加一个事件监听器。

如果锁释放了，会唤醒下一个序号的节点，然后重新执行第3步，判断是否自己的节点序号是最小。

## ElasticStack

倒排索引

