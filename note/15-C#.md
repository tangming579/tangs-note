## 反射

- 获取字段/属性/方法时间

  FieldInfo/PropertyInfo/MethodInfo

  ```csharp
  Type t = typeof(Person);
  FieldInfo m = t.GetField("Name");
  ```

  相关的元数据必须被执行获取，解析等操作。非常有趣的是，`运行时通过保留所有字段/属性/方法的内部缓存来帮助我们减少消耗

- 参数验证和错误处理

  运行时，需要对传入的值的数量和类型进行检查,它经常涉及`装箱`操作，会有额外的开销

- 安全性检查

  有一些受限制的或“危险的方法”，只能被.net框架代码调用

目前最常见的优化反射性能的方法就是采用委托：用委托的方式调用需要反射调用的方法（或者属性、字段）。

三种方法：Emit、Delegate.CreateDelegate、ExpressionTree

结论：

- 原生反射比直接调用慢出了两个数量级，性能差异达到了200倍
- .NET 4的动态编程dynamic相当简洁，其性能只比直接调用高出一个数量级，但其语法相当简洁
- 使用委托优化反射之后，其性能与直接调用相差无几，保持在同一个数量级之内
- 显式委托（Delegate）和匿名委托（Func）性能差异非常不明显，但显式委托的性能还是好一点； 

ExpressionTree可认为是Emit方法的简化版本， 所以Emit是最根本的方法，它采用在运行时动态构造一段IL代码来包装需要反射调用的代码， 这段动态生成的代码满足某个委托的签名，因此最后可以采用委托的方式代替反射调用。

## 表达式树

### Expression本质

- 表达式目录树是一个类的封装，描述了一个结构，有身体部分和参数部分
- 身体部分分为左边和右边，内部描述了左边和右边之间的关系，可以不断的往下拆分，类似于二叉树
- 表达式目录树展开后的每一个节点也是一个表达式目录树

### 和委托的区别

- 在委托外面包裹一层Expression<>就是表达式目录树
- 表达式目录树可以通过Compile()转换成一个委托

### 如何定义

- Expression<Func<TSource, bool>>就是表达式目录树
- Expression不能带有大括号，只能有一行代码

expression是一种数据结构，我们可以将平常编写的C#语句块（或者叫表达式）的各部分进行分解并存入这个树结构当中，保存在expression树结构中的语句块是不能直接执行的。
当我们需要将expression结构中的数据抽取并还原时就需要调用expression.Compile()方法,这里我称之为编译。编译后得到的结果就是我们之前存入的语句块，这是数据结构还原成语句块的过程（这是一个比喻）。

## 处理管道的区别

参考：http://www.fwhyy.com/2020/04/dotnet-core-3-request-processing-pipeline-and-middleware/

**ASP.NET 管道：**

1. 程序在 IIS 中运行后，会启动一个名为 w3wp.exe 的进程，利用 aspnet_isapi.dll 加载 .NET 运行时
2. 随后运行时 IsapiRuntime 会被加载，加载后，会接管整个 HTTP 请求，然后创建一个 IsapiWorkerRequest 对象来包装 HTTP 请求
3. IsapiWorkerRequest 传递给 ASP.NET 的 HttpRuntime ，这时请求就进入了 ASP.NET 的管道；
4. HttpRuntime 会根据 IsapiWorkerRequest 对象创建表示当前 HTTP 请求上下文 (Context) 对象 HttpContext；
5. HttpContext 创建后，HttpRuntime 会使用 HttpApplicationFactory 创建当前的 HttpApplication 对象，HttpApplication 对象会有多个，处理完后会被释放到 HttpApplication 的对象池中；
6. 到了 HttpApplication 中之后，就是我们所熟悉的 HttpModule 和 HttpHandler 了，先经过 HttpModule ，比如 ASP.NET 自带的授权、身份认证、缓存等就是通过 HttpModule 处理，我们也可以自定义自己的 HttpModule ，而具体的 aspx、ascx 等就是由 HttpHandler 处理。

**ASP.NET Core 管道：**

在 Core 中请求处理管道由一个服务器和一组中间件来组成，服务器默认就是内置的 Kestrel，请求经过中间件处理完后，进入下一个中间件，然后按照顺序依次返回。相比较原来的 HttpModule ，更简单和轻量级。

1. Modules, handlers, *Global.asax.cs*, *Web.config* 都被去掉了
2. Modules和Handlers都被中间件取代了，Web.config 通过中间件代码来配置

## 值传递与引用传递

参考：https://blog.csdn.net/longgetaotao_06/article/details/125941193

### 概念

- 形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了
- 实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。



- 值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
- 引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

### 误区

错误理解一：值传递和引用传递，区分的条件是传递的内容，如果是个值，就是值传递。如果是个引用，就是引用传递

错误理解二：C#值类型按值传递，引用类型按引用传递。

错误理解三：传递的参数如果是普通类型，那就是值传递，如果是对象，那就是引用传递。

### 严格模式

当进行方法调用的时候，需要把实际参数传递给形式参数，那么传递的过程中到底传递的是什么东西呢？求值策略定义何时和以何种顺序求值给函数的实际参数、什么时候把它们代换入函数、和代换以何种形式发生。

1.传值调用（值传递）：在传值调用中，实际参数先被求值，然后其值通过复制，在传递给被调函数的形式参数。因为形式参数拿到的只是一个"局部拷贝"，所以如果在被调函数中改变了形式参数的值，并不会改变实际参数的值。

2.传引用调用（引用传递）在传引用调用中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。因为传递的是引用，所以，如果在被调函数中改变了形式参数的值，改变对于调用者来说是可见的。

3.传共享对象调用（共享对象传递）传共享对象调用中，先获取到实际参数的地址，然后将其复制，并把该地址的拷贝传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们也称之为"传共享对象"，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。

**因为传共享对象调用的过程和传值调用的过程是一样的，而且都有一步关键的操作，那就是"复制"，所以，通常我们认为传共享对象调用是传值调用的特例**

总结

- 如果参数是基本类型的话，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。