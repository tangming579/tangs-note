## 反射

- 获取字段/属性/方法时间

  FieldInfo/PropertyInfo/MethodInfo

  ```csharp
  Type t = typeof(Person);
  FieldInfo m = t.GetField("Name");
  ```

  相关的元数据必须被执行获取，解析等操作。非常有趣的是，`运行时通过保留所有字段/属性/方法的内部缓存来帮助我们减少消耗

- 参数验证和错误处理

  运行时，需要对传入的值的数量和类型进行检查,它经常涉及`装箱`操作，会有额外的开销

- 安全性检查

  有一些受限制的或“危险的方法”，只能被.net框架代码调用

目前最常见的优化反射性能的方法就是采用委托：用委托的方式调用需要反射调用的方法（或者属性、字段）。

三种方法：Emit、Delegate.CreateDelegate、ExpressionTree

结论：

- 原生反射比直接调用慢出了两个数量级，性能差异达到了200倍
- .NET 4的动态编程dynamic相当简洁，其性能只比直接调用高出一个数量级，但其语法相当简洁
- 使用委托优化反射之后，其性能与直接调用相差无几，保持在同一个数量级之内
- 显式委托（Delegate）和匿名委托（Func）性能差异非常不明显，但显式委托的性能还是好一点； 

ExpressionTree可认为是Emit方法的简化版本， 所以Emit是最根本的方法，它采用在运行时动态构造一段IL代码来包装需要反射调用的代码， 这段动态生成的代码满足某个委托的签名，因此最后可以采用委托的方式代替反射调用。

## 表达式树

### Expression本质

- 表达式目录树是一个类的封装，描述了一个结构，有身体部分和参数部分
- 身体部分分为左边和右边，内部描述了左边和右边之间的关系，可以不断的往下拆分，类似于二叉树
- 表达式目录树展开后的每一个节点也是一个表达式目录树

### 和委托的区别

- 在委托外面包裹一层Expression<>就是表达式目录树
- 表达式目录树可以通过Compile()转换成一个委托

### 如何定义

- Expression<Func<TSource, bool>>就是表达式目录树
- Expression不能带有大括号，只能有一行代码

expression是一种数据结构，我们可以将平常编写的C#语句块（或者叫表达式）的各部分进行分解并存入这个树结构当中，保存在expression树结构中的语句块是不能直接执行的。
当我们需要将expression结构中的数据抽取并还原时就需要调用expression.Compile()方法,这里我称之为编译。编译后得到的结果就是我们之前存入的语句块，这是数据结构还原成语句块的过程（这是一个比喻）。

## 处理管道的区别

参考：http://www.fwhyy.com/2020/04/dotnet-core-3-request-processing-pipeline-and-middleware/

**ASP.NET 管道：**

1. 程序在 IIS 中运行后，会启动一个名为 w3wp.exe 的进程，利用 aspnet_isapi.dll 加载 .NET 运行时
2. 随后运行时 IsapiRuntime 会被加载，加载后，会接管整个 HTTP 请求，然后创建一个 IsapiWorkerRequest 对象来包装 HTTP 请求
3. IsapiWorkerRequest 传递给 ASP.NET 的 HttpRuntime ，这时请求就进入了 ASP.NET 的管道；
4. HttpRuntime 会根据 IsapiWorkerRequest 对象创建表示当前 HTTP 请求上下文 (Context) 对象 HttpContext；
5. HttpContext 创建后，HttpRuntime 会使用 HttpApplicationFactory 创建当前的 HttpApplication 对象，HttpApplication 对象会有多个，处理完后会被释放到 HttpApplication 的对象池中；
6. 到了 HttpApplication 中之后，就是我们所熟悉的 HttpModule 和 HttpHandler 了，先经过 HttpModule ，比如 ASP.NET 自带的授权、身份认证、缓存等就是通过 HttpModule 处理，我们也可以自定义自己的 HttpModule ，而具体的 aspx、ascx 等就是由 HttpHandler 处理。

**ASP.NET Core 管道：**

在 Core 中请求处理管道由一个服务器和一组中间件来组成，服务器默认就是内置的 Kestrel，请求经过中间件处理完后，进入下一个中间件，然后按照顺序依次返回。相比较原来的 HttpModule ，更简单和轻量级。

1. Modules, handlers, *Global.asax.cs*, *Web.config* 都被去掉了
2. Modules和Handlers都被中间件取代了，Web.config 通过中间件代码来配置