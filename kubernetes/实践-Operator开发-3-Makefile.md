Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的自动编译和链接的规则。Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。

### 变量

| 变量      | 解析                                                         |
| --------- | ------------------------------------------------------------ |
| $0        | 当前脚本的文件名。                                           |
| $n（n≥1） | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2>。 |
| $#        | 传递给脚本或函数的参数个数。                                 |
| $*        | 传递给脚本或函数的所有参数。                                 |
| $@        | 表示目标文件。                                               |
| $?        | 上个命令的退出状态，或函数的返回值。                         |
| $$        | 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 |
| $^        | 表示所有的依赖文件                                           |
| $<        | 表示第一个依赖文件                                           |

### 变量赋值

| 变量 | 解析                               |
| ---- | ---------------------------------- |
| =    | 最基本的赋值                       |
| :=   | 覆盖之前的值                       |
| ?=   | 如果没有被赋值过就赋予等号后面的值 |
| +=   | 添加等号后面的值                   |

1、"**=**"是最普通的等号，在Makefile中容易搞错赋值等号，使用 “=”进行赋值，变量的值是整个Makefile中最后被指定的值。

```text
VIR_A = A
VIR_B = $(VIR_A) B
VIR_A = AA
```

VIR_B的值是AA B，而不是A B，在make时，会把整个Makefile展开，来决定变量的值

2、"**:=**" 表示直接赋值，赋予当前位置的值。

```text
VIR_A := A
VIR_B := $(VIR_A) B
VIR_A := AA
```

最后BIR_B的值是A B，即根据当前位置进行赋值。因此相当于“=”，“：=”才是真正意义上的直接赋值

### 规则

```
语法：
[目标]: [依赖]
(tab制表符)[命令]xxxxxxxxxx 语法：[目标]: [依赖](tab制表符)[命令]...
```

- **目标**：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；
- **依赖**：是我们的依赖文件，要生成 targets 需要的文件或者是另一个目标。可以是多个，也可以没有；
- **命令**：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。

这是一个文件的依赖关系，也就是说，`<target>`这一个或多个的目标文件依赖于`<prerequisites>`中的文件，其生成规则定义在 `<command>`中。说白一点就是说，`<prerequisites>`中如果有一个以上的文件比`<target>`文件要新的话，`<command>`所定义的命令就会被执行。这就是makefile的规则。也就是makefile中最核心的内容。

### 伪目标 .PHONY

.PHONY是一个伪目标，Makefile中将.PHONY放在一个目标前就是指明这个目标是伪文件目标。其作用就是防止在Makefile中定义的执行命令的目标和工作目录下的实际文件出现名字冲突。

```
clean:
    rm -f *.o 
```

如果该**Makfile文件所在目录不存在名为clean的文件**，使用make clean命令运行该Makfile时，正常清除所有的.o后缀文件。

如果该**Makfile文件所在目录存在名为clean的文件**，再次使用make clean命令运行该Makfile，命令会失效！

**通俗一点讲，**就是.PHONY修饰的目标clean并不是某个依赖项生成的实际文件，因此make命令不再去搜寻当前文件夹下是否有clean文件，这样少去做一些事，自然会改善性能，并且不用担心当前文件夹下是否有同名的文件。